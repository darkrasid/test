docker로 개발환경 구축

docker로 개발환경을 구축하면 꽤 많은 이점이 있습니다. 우선 내 로컬머신이 깨끗해져 이것저것 설치해야하는 걱정이 없습니다. 또 운영과 환경적인 차이도 줄어듭니다. 로컬에서는 재현이 안되는데 운영에서만 안되는 이상한 현상들 다 한번씩 경험해보셨을텐데 그런 현상을 미연에 방지하기 쉽습니다. 근데 사실 실제로 해보면 어느정도 누군가 고생하지 않으면 단점이 훨씬 많습니다. 개발환경이라는 건 언제든 접근가능하고 내가 해보고 싶은대로 막 해봐야 좋은데 이미 중간에 컨테이너라는 한단계가 더 들어가기 때문에 그냥 내 로컬에서 돌릴 때와는 분명 조금더 해야할 작업들이 있습니다. 이건 제가 나름대로 docker 환경을 개발환경으로 사용하면서 겪었던 이것저것 경험담에 대한 이야기입니다. 

여기서 다루는 내용은
- docker에 대한 전반적인 내용
- docker container를 개발환경으로 사용하기 위한 템플릿
같은 그림같은 내용따위는 없습니다. 대신에 docker를 개발환경으로 사용하면서 틈틈히 알게되었던 알면 좋은 몇가지 도커 상식과 삽질기만 있습니다. 

저는 ubuntu 머신을 개발할 때 사용하고 있는데 제 ubuntu 머신에 설치되어 있는건 다른 dependency를 해결하기 위한 패키지 이외에는 git과 docker만 설치되어 있습니다. 아 vim도 있네요. 저는 업무상 rails를 많이 사용하는데 ruby도 설치가 되어 있지 않습니다. 대신에 rails테스트를 해야하는 경우가 생기면 rails가 설치되어 있는 container 위에서 작업합니다. 

가장 간단한 container 개발환경은 
```
sudo docker run -it rails_image bash
```
로 실행해서 사용할 수 있습니다. 엄청 간단하고도 docker를 처음 배울 때 hello-world run 다음에 실행시켜 보는 스크립트입니다. 사실 명령어 한 줄이지만 아무도 rails_image를 미리 만들어 놓지 않았다면 저건 절대 간단한 스크립트가 아닙니다. 

rails_image의 Dockerfile은 아래와 같습니다. 

```
dockerfile rails
```

사실 사내에선 프록시 뚫고 저거 build하는 것만 해도 처음해보면 하루는 잡아야 합니다. 꼬이면 더 걸릴 수도 있구요..어찌됐건 위의 스크립트로 간단한 rails container가 만들어졌습니다. 지금부터 해야하는건 rails test를 스크립트 실행으로 생성된 bash환경에서 하는 것입니다. 근데 사실 저거 너무 허술합니다. 문제점이 너무 많죠. 우선 저 container는 bash하나를 command로 잡았기 때문에 저 bash가 닫히는 순간 container가 내려갑니다. 게다가 container가 삭제되지 않는한 데이터는 남는다지만 docker container 하나를 신주단지 모시듯 할 수는 없죠. 작업한 데이터따위.. 날아가도 된다면 모르겠지만요. 거기에 image에 git도 설치해야 하네요. 저는 개인적으로 vim을 에디터로 사용하는데 제가 설치한 모든 vim plugin 따위 아무것도 없습니다. 새로 설치해야하죠. 게다가 vim을 안쓴다면? 아마 ftp로 연결하거나 ssh로 ide에 연결해서 파일을 편집해야 할 텐데 ssh port도 안뚫려있네요. 솔직히 이 상태로 개발환경이라고 칭하긴 좀 민망하네요.

그럼 조금만 발전 시켜 볼까요. 

```
sudo docker run -itd rails_image bash
```
백그라운드로 실행시켰습니다. 이제 실수로 bash창을 닫음으로서 container가 멈추는 사태는 방지할 수 있겠네요. 수동으로 stop시키지 않는다면요. 접근은 
```
sudo docker exec -it container_id bash
```
로 몇개든 bash창을 띄워 개발할 수 있습니다. 근데 여전히 vim plugin같은걸로 개발할 수 있는 상황은 아니네요. 조금 더 발전시켜보면
```
sudo docker run -v $(pwd)/workdir:/home/some/where -it -d bash
```
docker를 run 시키는 부분을 volume으로 마운트했습니다. 저 스크립트 대로라면 실행시키는 위치가 대단히 중요하겠죠. 이렇게 띄워놓고 보면 이제 굳이 exec로 container내부를 들어가 무언갈 편집할 필요가 없습니다. 밖에 뭔가 파일을 만들면? 그건 container 내부에 파일이 생성될테니까요. 그러면 이제 개발환경은 두부분으로 나뉘게 됩니다. file을 편집하는 내 local머신과 명렁어를 수행하는 container가 생성되게 되는거죠. file을 작성하는 건 그냥 평소에 하듯 vim으로 하고 bundle install같은 rails에 국한된 작업은 docker 내부에서 하면 됩니다. `docker exec -it container_id cd /home/some/where && bundle install` 요렇게 가능하죠. 전보단 나이스한거 같네요. container 내부에 직접 접근할 필요가 없어졌습니다. 그럼 한번 생각대로 되는지 한번 테스트 해보겠습니다.

```
cd workdir && touch test.rb
```
어라 안되네요. 에러납니다. 권한 문제가 생기네요. 역시 뭐하나 쉬운게 없죠. 이 권한 문제는 뒤에서 설명할 이미 만들어진 app의 개발환경을 dockerize하는 과정에서도 계속에서 골머리를 썩히는 부분입니다. 제가 아는 한 아직 이부분은 아직 나이스하게 뙇하고 풀어하는 솔루션같은건 안나왔습니다. 대신 docker가 user를 어떤식으로 다루는지를 이해하고 image에 반영해 놓을 수 밖에 없습니다. 여기서 docker의 짤막한 user를 어떻게 다루는가에 대해 조금 알아보겠습니다. docker를 처음공부하면 늘 따라나오는 docker가 container를 격리하기 위해 쓰는 기술인 namespace에 대해 공부하게 됩니다. 그중에서도 대표적으로 network  namspace와 pid namespace를 알게 됩니다. 이 두 기술덕에 docker에서 container를 run할 때 별 다른 옵션을 두지 않아도 network와 pid가 격리됩니다. 근데 user namespace라는 개념이 있음에도 불구하고 user는 container에서 격리 되지 않습니다. 

pid는 container를 run할 때 쓰는 cmd가 1번 process를 차지하게 됩니다. container내부에서는요. 근데 그 1번 pid는 사실 host입장에선 몇백번때 (호스트에서 실행되고 있는 pid수에 따라 다르겠죠) pid를 가집니다. 이런식으로 개념적으로 격리가 이루어지죠. 근데 user는 그딴 거 없습니다. container에서의 root는 host에서도 root입니다. 그럼 제가 container에 pilsner라는 계정을 만들었다고 가정해보면 그건 host에서도 pilsner계정일까요? 답은 그럴 수도 있고 아닐 수도 있습니다. 사실 username은 중요하지 않고 uid가 같은 계정으로 맵핑이 됩니다. 만약 container내부의 pilsner 계정의 uid가 1000번이라면 host머신에 1000번을 가지는 user와 같은 유저입니다. 반대도 마찬가지구요. 근데 일단 container는 실행될 때 무조건 sudo 권한을 가지고 올라갑니다. 물론 docker를 처음 설치하면 docker라는 그룹을 만들고 내 계정을 거기에 포함시켜 sudo를 빼고 docker를 사용할 수도 있지만 docker 자체가 linux의 커널 영역을 핸들링해야 하기 때문에 sudo 권한을 아예 포기하고 올라가는 건 아닙니다. 그리고 run될 때 별다른 옵션을 안주면 무조건 root권한으로 올라갑니다. 때문에 우리가 잡은 볼륨 영역도 사실은 container내부에서 root권한을 가지고 있게 되고 그건 곧 host의 root권한이죠. ls -al로 한번 확인해보면 제가 별다른 권한을 안줬지만 root권한으로 volume 영역이 잡혀 있는 것을 확인할 수 있습니다. 이래버리면 이제 제가 뭔가 편집하고 싶을 때마다 sudo vim 이런식으로 진행해야하고 git을 쓰고 싶어도 sudo git .. 이건 좀 아니죠. 그럼 이걸 해결하기 위해서 container로 접근해서 user하나를 만들어보겠습니다. `adduser aaa ` uid를 1000으로 줘야하지만 제 contianer의 base가 ubuntu이고 ubuntu에선 첫번째 유저의 uid는 디폴트로 1000이니까 따로 주진 않겠습니다. 그리고 아까 만들었던 영역을 aaa 계정으로 권한을 주고 다시 호스트에서 touch해보면 잘되네요. 근데 맨날 뭐하나 할때마다 들어가서 유저생성하고 uid주고 작업공간에 권한 줄 순 없잖아요? 그래서 처음에 dockerfile을 만들 때 내 uid에 해당하는 user를 만들고 volume을 그 유저의 홈 밑으로 잡으면 됩니다. 
그럼 git flow같은 편집 관련된 모른 프로세스는 그냥 내 홈에서 진행하고 서버 스타트 등은 container내부에서 진행할 수 있습니다. 그리고 자연스레 내 container는 rails 외에 다른 데이터를 가지고 있을 필요가 없습니다. 모든 편집 산출물은 host에 존재하니까요 자연스레 스테이트리스 상태가 되죠. 그러니 언제든 container가 날아가도 상관없어집니다. 

user를 줄수도 있음 --user => 이 방법도 괜찮은데 /etc/passwd를 공유하지 않으면 no-name이 뜨긴 함 -v 옵션으로 /etc/passwd를 공유해도됨 => ro 로 근데 매번 이거 치는게 귀찮을 수 있음 그럼 그냥 image만들때 uid 1000을 만드는 것도 방법임 그리고 이게 사실 지금 가장 많은 이미지에서 채택하고 있는 방법이기도 함 보통 1000 uid를 가지도록 하드코딩해버림 왜냐면 우분투나 센트같은 곳에서 id하나 새로 생성하면 부여되는게 1000이기 때문임 개인적으로 이 방법이 더 좋다고 생각하는게 sudo가 필요한 작업을 할때는 확실히 더 좋음 image 레벨에서 미리 user를 sudo권한을 가지도록 변경해놓으면 되기 때문임 . 
그리고 여기서 onbuild를 좀 활용하면 이걸 배포해서 이 지식 없는 사람도 좀 쉽게 사용하게 만들 수 있음 

저걸 해결하기 위해서 몇가지 실험을 해봐야함 image만들 때 생성된 user의 uid를 변경했을 때 무슨 일이 생기는가 잘되는가 onbuild로 한다면?? 흐음 => 이거 괜찮음 잘됨

onbuild로 잘되긴하는데 몇가지 문제가 있음
user로 세팅하는 부문도 onbuild로 하지않으면 user 로 잡는 부분때문에 user가 변경됨 => USER pilsner 부분도 onbuild로 해야함 그리고 ONBUILD는 이미 생성된 이미지 뒤의 build를 미리 지정해놓는 것이기 때문에 순서와 상관없음.. 


이정도까지 해결해놓으면 어느정도 편하게 개발할 수 있음. host에서 늘 하듯 서버를 띄워 놓은 채로 편집하고 필요에 의하면 container 내부에서 서버 리스타트를 시키면 됨. 
근데 조금만 더 나아가서, 제가 원했던 궁극적인 형태는 컨테이너는 띄워져있더라도 저는 거기 안을 들여다 볼 필요가 없는 상태입니다. 사실 여기까지 구성했다면 어느정도 컨테이너 세상과 호스트의 세상으로 나누어 비교적 편리하게 사용할 수 있지만 여전히 container에 계속해서 접근해야 합니다. 이걸 안하려면 host에서 컨테이너로 명령어를 던지면 되긴합니다. 예를 들면
```
sudo docker exec -d container_name bundle exec rails s -b 0.0.0.0 -p 3000
```
이 script는 container내부에서 rails server를 시작하는 방법입니다. 근데 위의 dockerfile만으로 이걸 실행했다간 바로 에러가 납니다. 왜냐면 dir이 안맞으니까요 이걸 맞추려면 dockerfile에 내가 작업할 공간을 workdir로 잡아놔야 합니다. 그럼 잘 실행이 되네요. 그럼 이제 내가 뭔가 수정했다고 가정하고 restart해볼께요. 
```
sudo docker exec -it container_name bundle exec rails ?
```
엉? restart는 사실 저 프로세스를 죽이고 다시 start인데.. 명령어로 적절하게 풀어내기가 쉽지 않습니다. 그럼 아까 실행시킨 저 프로세스 어떻게 찾아내죠? 이렇게 모든 명령어를 exec아래로만 두어서는 이것저것 아다리가 안맞습니다. 그래서 제가 추천하는 방법은 rails s -b 0.0.0.0 -p 3000 부분을 entrypoint나 cmd로 빼는 방법입니다. 그럼 그냥 sudo docker restart container_name 으로 서버가 restart가 되죠. 그리고 어떤 프로세스를 전부 detach해버리면 저런식으로 추적하기가 어렵습니다. 제가 추천하는 방법은 exec를 사용하지 말고 docker run -it --rm image command 형태로 실행시키는 것입니다. 예를 들면 저렇게 server가 스타트 된 상태에서 어떤 빌드잡을 돌려야 한다면

```
sudo docker run --rm -d -v $(pwd)/workdir:/home/some/where image bundle install
```
위의 명령어는 rails에서 gem file들을 설치하는 스크립트입니다. 저러면 개발하며 쌓이는 모든 데이터는 이미 host가 받기 때문에 install된 gem들도 남습니다. 혹시 뭔가 행걸려도 container가 떠있으니 추적하기가 쉽고 hang없이 끝났다면 container가 제거되니 편리합니다. 

근데 저걸 맨날 쳐야되잖아요 그걸 스크립트로 빼면 좀더 쉽습니다. 예를 들면
```
#!/bin/bash
sudo docker run --rm -d -v $(pwd)/workdir:/home/some/where image $@
```
이러고 사용은 ./script.sh command가 되겠죠. 


근데 이쯤되면 뭔가 속이 간질거리시는 분들도 있을텐데 점점 dockerfile도 복잡해지고 script파일도 등장하기 시작했네요. 이게 서두에 말씀드린 docker container를 뭔가 개발환경답게 사용하려면 그리 녹록치않다고 말씀드린 부분이기도합니다. 조금더 편리한 개발환경은 조금더 부지런한 개발자의 코딩이 필요합니다. 또 하나의 문제는 저도 이 과정을 쭉 겪어오는 기간이 그리 짧지 않았습니다. 지금은 docker 기술 자체에 관심이 있었기 때문에 왠만한 개념은 대충 이해하고 편하게 쓰지만 이런 문제를 저렇게 또 저런 문제는 이렇게 푸는 과정을 익히는 시간이 짧지 않았죠. 모든 개발자에게 이런 과정을 겪으라고 할 순 없는 거죠. 그러니 rails프로젝트를 뭔가 시작한다.. 하면 누군가는 이 과정을 모두 담은 container를 개발환경으로 사용할 수 있게 미리 만들어놓은 image와 script등이 필요합니다. 개발자 개인의 능력으로 이걸 구성하는 것은 전 부정적입니다. 


근데 여기까지 한 건 새로운 프로젝트를 새로 시작할 때 쓸만한 것 입니다. 예를 들면 이클립스에서 new java project를 어떻게 하는지 알아본거죠. 근데 사실 이렇게 개발을 시작하는 사람보다는 이미 어느정도 진행중인 프로젝트를 받아 개발을 시작할 때가 훨씬 많죠. 이러면 이제부터 이야기가 엄청 복잡해집니다. 앞에서 다룬건 rails를 기본으로하는 project를 시작할 때 이미 rails가 세팅되어 있는 공간에 뭔가를 만들면 됐었죠. 근데 rails든 spring이든 프레임워크 하나로 개발할 수는 없겠죠. 인메모리 쓰겠다고 redis를 쓰거나 db를 쓰겠다고 postgres를 쓰거나 등등 하게 될텐데 위의 방법대로 하나 볼륨잡고 로딩하고 postgres docker는 어떻게 쓰는건가 공부하고 붙이고 redis는 어케 쓰나 보고 붙이고 하느니 그냥 docker container 개발환경을 포기하는게 낫죠. 

그래서 이 경우엔 누군가 한명 총대를 메야 합니다. 누군가 이 모든게 뙇하고 세팅되는 개발환경을 만들어주는 docker image를 만들어서 배포해야 하는거죠. 이걸 만약에 완성하게 되면 분명한 장점이 있습니다. container base로 움직이기 때문에 왠만해선 뻑나지 않고 새로온 개발자도 한방에 개발환경을 가져갈 수가 있죠. 근데 한명은 솔직히 좀 개고생해야 됩니다. 개인적으로 이렇게 만드는걸 시도해본건 두가지가 있는데 하나는 discourse이고 하나는 gitlab입니다. gitlab은 gitlab 그 자체의 문제와 요즘 github이 들어오는 특수성 때문에 거의 다 완성한 상태에서 홀드한 상태이긴 합니다. 근데 문제는 이 docker로 된 개발환경을 만드는 과정은 docker로 된 운영 이미지를 만드는 과정보다 체감으로 2~3배는 어렵고 더 손이 많이 갑니다. 고려해야할 사항도 엄청나게 많구요. 왜냐면 위에껀 그냥 내 컴터에 뭔가 하는 거니까 내꺼에 맞춰서 하면 되는데 개발환경을 미리 세팅하는 과정은 사용자가 누군지 모르는 문제가 발생합니다. 

지금부터는 제가 만들면서 삽질했던 부분들 이런건 이렇게 처리하면 좋다하는 부분에 대해서 다뤄보겠습니다. 

1. entrypoint를 조심하자
일단 개발환경을 만들자하고 시작하면 먼저 접근하는게 운영중인 image일 가능성이 큽니다. 이 image를 바탕으로 뭔가를 해볼려고 할 때 가장먼저 조심해야 하는것이 entrypoint입니다. docker와 vm의 가장 큰 차이중의 하나는 목적성에 있다고 개인적으로 생각하는데 그걸 확실히 확인시켜주는 것이 docker의 run 명령어 입니다. vm은 인스턴스를 킬 때 부팅과정을 겪습니다. 그리고나서 서버를 띄우겠죠. 이 서버가 내려간다 한들 vm은 서버가 내려간 vm이 될 뿐입니다. 근데 docker는 다릅니다. docker에서 만들어지는 container는 그 마다 하나의 목적을 가지게 됩니다. 그건 command일 수도 있고 entrypoint일 수도 있습니다. 근데 컨테이너는 이 목적으로 설정된 녀석이 죽으면 그냥 container가 내려가 버립니다. container입장에선 임무를 다 한거죠. 이건 조금더 파고들면 entrypoint나 command가 docker container 의 1번 process이기 때문입니다. 모든 *inx 프로세는 1번 프로세스의 하위 프로세스이니 1번 프로세스가 죽어버리면 그냥 내려가는 거죠. 그러니 production 모드로 되어 있던 image 내부에 가서 첫걸음을 내딛겠다고 디벨롭 모드로 바꾸고 서버 리스타트하면 서버가 리스타트되는게 아니라 container가 리스타트됩니다. 그거 다시키면? image가 어떻게 만들어졌냐에 따라 다르겠지만 대부분 image는 그거 다시 키는 순간 entrypoint가 바로 실행되죠. 그럼 보통 둘중하나입니다. 소스가 원래 소스로 되돌아 가던지 아니면 entrypoint는 운영모드로 서버를 스타트하고자 하는데 세팅값이 development이니 죽어버리겠죠. 이러니 entrypoint부터 오버라이드해놓고 시작하는 것이 좋습니다. 처음에 이거 정확히 몰라서 원인찾는다고 고생좀 했었습니다.

2. 더 많은 기능을 원할 수록 더 복잡해진다는 것을 기억하자. 
이건 다들 아시는 내용일 수도 있습니다. 저는 개인적으로 그냥 shell 명령어 한줄 치면 완성되는 개발환경을 원했습니다. 무릇 docker 로 개발환경을 만드는데 사용자가 이것저것 세팅하고 알아서 싱크를 맞추는 그런 모습이 아니길 원했죠. 그때로 제가 돌아가면 제 뺨 한대 때리고 싶네요. 이걸 적당히 타협할 수 있으면 좀 버든이 줄어듭니다. 근데 전 그러지 못했죠. 망할. 어쨋든 전 개인적으로 사용자가 넣을 수 있는 최소한의 정보만 넣으면 모든것을 세팅해서 구동되는 개발환경을 원했습니다. 그러면서 위에 다뤘던 권한과 볼륨 마운트등을 해서 host에선 그냥 쓰듯이 쓰고 rails의 도움이 필요한 부분만 contaienr 내부에서 구동되길 바랬습니다. 

3. exec의 command도 entrypoint의 인자값임을 명심해야한다. 

4. docker 개발환경의 단점은 내부를 보기 어렵다는 것. 
이걸 만드는 사람 입장에서 모든것을 안다고 생각하고 세팅하면 사실 좀 더 편하게 만들 수 있습니다. docker-compose에 모든 것을 넣고 한번은 세팅하게 돌리고 한번은 command 바꿔서 돌리면 되긴 하죠. 


원래 처음 도커 개발환경으로 변경해야지 하고 마음먹고 시작한건 image안에 꾸역꾸역 다 넣어놓고 redis수배 하고 postgres수배하고 뙇하고 연결하면 사용자가 사용할 수 있는 환경을 만들 수 있을 줄 알았습니다. 근데 안되요. 망할 왜냐면 위에 쭉 했던 작업들을 포기하면 가능합니다. 근데 저렇게 해버리면 뭔가 시작할 때마다 사용자가 exec로 들어가서 개발해야 합니다. 왜나면 볼륨이 host쪽 우선으로 붙기 때문이죠. - 여기서 볼륨에 대해 설명

이런 이유로 개발환경 도커 이미지는 discourse를 예로 들자면 rails만 설치된 이미지에서 entrypoint가 그 외 모든 개발환경을 세팅하는 롤을 가져가게 됩니다. 이거 엄청 익숙하죠. 결국 container내부에서 구동되는  배포잡 하나 짜야되는거죠. 근데 이게 운영 배포잡보다 더 짜증나는게 사용자가 누가될지 모르잖아요 그러니 개발환경에 커스텀할 수 있는 부분을 남겨놔야 합니다. 


일단 좀 진행중인 project를 혹은 운영으로 가져가고 있던 플젝의 개발환경을 docker로 가져오게되면 몇가지 난제가 발생하는데 멏번쪠는 이미 소스가 있다는 거죠. 위의 방식은 아무것도 없는 곳에서부터 시작했기때문에 볼륨만 잡고 거기서 작업하면 모든게 끝났죠. 근데 이제 그게 아니에요. 내가 소스를 dockerfile에서 미리 넣어놓고 volume을 잡는다 한들 volume은 host위주로 세팅되니 container 내부 로직은 죄다 날아가게 됩니다. 볼륨 설명 ! 
